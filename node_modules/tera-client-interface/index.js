const net = require('net');
const path = require("path");
const { execFileSync } = require("child_process");
const EventEmitter = require('events');
const ModuleManager = require('./moduleManager');
const ProcessListener = require("./process-listener");

class TeraClientInterfaceConnection extends EventEmitter {
    constructor(socket, moduleFolder) {
        super();
        this.setMaxListeners(0);

        this.socket = socket;
        this.buffer = null;

        this.dataQueryEventEmitter = new EventEmitter;
        this.nextDataQueryId = 0;

        this.moduleManager = new ModuleManager(this, moduleFolder);

        this.socket.on('data', data => {
            this.buffer = this.buffer ? Buffer.concat([this.buffer, data]) : data;

            let start = 0;
            let end = -1;
            while ((end = this.buffer.indexOf(0, start)) >= 0) {
                if (end > start) {
                    const packet = this.buffer.slice(start, end);
                    try {
                        const parsed = JSON.parse(packet);
                        if (parsed.command === 'dcresult')
                            this.dataQueryEventEmitter.emit(parsed.data["id"].toString(), parsed.data);
                        else
                            this.emit('data', parsed.command, parsed.data || {});
                    } catch (e) {
                        console.log(`[toolbox] Error communicating with client:`);
                        console.log(e);
                    }
                }

                start = end + 1;
            }

            this.buffer = this.buffer.slice(start);
        });

        this.socket.once('error', e => {
            this.emit('disconnect', e);
            this.socket = null;
            this.destructor();
        });

        this.socket.once('close', () => {
            this.emit('disconnect');
            this.socket = null;
            this.destructor();
        });
    }

    send(command, data = {}) {
        if (this.socket)
            this.socket.write(JSON.stringify({ command, data }) + "\x00");
    }

    destructor() {
        this.removeAllListeners();

        if (this.moduleManager) {
            this.moduleManager.destructor();
            this.moduleManager = null;
        }

        if (this.dataQueryEventEmitter) {
            this.dataQueryEventEmitter.removeAllListeners();
            this.dataQueryEventEmitter = null;
        }

        if (this.socket) {
            this.socket.end();
            this.socket.destroy();
            this.socket = null;
        }
    }

    queryData(query, queryArgs = null, findAll = false) {
        const queryId = this.nextDataQueryId++;

        const res = new Promise((resolve, reject) => {
            this.dataQueryEventEmitter.once(queryId.toString(), result => {
                if (result.success)
                    resolve(result.data);
                else
                    reject(result.error);
            });
        });

        this.send('dcquery', {
            id: queryId,
            query: query,
            arguments: queryArgs,
            findall: findAll,
        });

        return res;
    }

    flashWindow(count = 5, interval = 0, allowFocused = false) {
        if (typeof (count) !== 'number')
            throw new Error('Count must be a number!');
        if (typeof (interval) !== 'number')
            throw new Error('Interval must be a number!');
        if (typeof (allowFocused) !== 'boolean')
            throw new Error('AllowFocused must be a boolean!');

        this.send('flashwindow', { count, interval, allowFocused });
    }

    configureCameraShake(enabled, power = 1.0, speed = 1.0) {
        if (typeof (enabled) !== 'boolean')
            throw new Error('Enabled must be a boolean!');
        if (typeof (power) !== 'number')
            throw new Error('Power must be a number!');
        if (typeof (speed) !== 'number')
            throw new Error('Speed must be a number!');

        this.send('camerashake', { enabled, power, speed });
    }

    suspend() {
        this.send('suspend', {});
    }

    resume() {
        this.send('resume', {});
    }
}

class TeraClientInterfaceServer {
    constructor(host, port, moduleFolder, onAccept, onReady, onError) {
        this.host = host;
        this.port = port;
        this.moduleFolder = moduleFolder;
        this.onAccept = onAccept;

        this.connections = new Set;

        this.server = net.createServer(socket => this.accept(socket));
        this.server.on('listening', () => onReady());
        this.server.on('error', e => onError(e));

        this.processListener = new ProcessListener("TERA.exe", this.handleAddedProcess, this.handleRemovedProcess, 1000);
    }

    destructor() {
        this.processListener.stop();
        this.processListener = null;

        this.connections.forEach(connection => connection.destructor());
        this.connections.clear();

        this.server.close();
        this.server = null;

        this.onAccept = null;
    }

    run() {
        this.server.listen(this.port, this.host);
        this.processListener.start();
    }

    accept(socket) {
        socket.setNoDelay(true);

        const connection = new TeraClientInterfaceConnection(socket, this.moduleFolder);
        this.connections.add(connection);
        socket.once('error', () => this.connections.delete(connection));
        socket.once('close', () => this.connections.delete(connection));

        this.onAccept(connection);
    }

    handleAddedProcess(process) {
        try {
            execFileSync(path.join(__dirname, "injector.exe"), [process.pid, path.join(__dirname, "tera-client-interface.dll")]);
        } catch (e) {
            console.log(`[toolbox] ERROR: Unable to connect to game client (PID ${process.pid})!`);
            switch (e.code) {
                case 'ENOENT': {
                    console.log("[toolbox] injector.exe does not exist. It has likely been deleted by your anti-virus.");
                    console.log("[toolbox] Disable/uninstall your anti-virus or whitelist TERA Toolbox and injector.exe!");
                    break;
                }
                case 'EPERM': {
                    console.log("[toolbox] Permission to launch injector.exe denied. It has likely been blocked by your anti-virus.");
                    console.log("[toolbox] Disable/uninstall your anti-virus or whitelist TERA Toolbox and injector.exe!");
                    break;
                }
                default: {
                    switch (e.status) {
                        case 1:
                        {
                            console.log("[toolbox] Connection to game client unsuccessful.");
                            console.log("[toolbox] > Make sure that TERA Toolbox is running with Administrator privileges!");
                            console.log("[toolbox] > Disable/uninstall your anti-virus or whitelist TERA Toolbox and injector.exe!");
                            break;
                        }
                        default:
                        {
                            console.log("[toolbox] This is likely caused by your anti-virus interfering. Disable/uninstall it or whitelist TERA Toolbox.");
                            console.log("[toolbox] Full error message:");
                            console.log(e);
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }

    handleRemovedProcess(pid) {
        // Do nothing.
    }
}

module.exports = TeraClientInterfaceServer;
